{"version":3,"sources":["../js/GraphNode.js"],"names":["$rdf","require","fetch","Headers","h","window","GraphNode","Impl","arguments","nodes","graph","sources","_graph","Array","isArray","termType","indexOf","value","split","Promise","resolve","uri","rdfFetch","then","response","node","f","results","map","all","predicate","each","statements","statementsMatching","undefined","statement","subject","Error","length","options","login","plainFetch","init","headers","get","set","ok","reject","mediaType","text","parse","error","ggg","status","console","log","module","exports"],"mappings":"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","sourcesContent":["var $rdf = require(\"ext-rdflib\");\nvar fetch = require(\"node-fetch\");\n\n/**\n * Node Status:\n * \n * Locally undetermined: There are multiple local nodes satisfying the criteria specified for this object \n * Blank: The object represents a blank node in a graph that is locally available\n * Unresolved: This node is identified by a URI that has not yet been derefernced\n * \n * @type type\n */\n\nlet Headers = ((h) => h ? h : window.Headers)(fetch.Headers);\n\nfunction GraphNode() {\n    return new GraphNode.Impl(...arguments);\n}\n\nGraphNode.Impl = class {\n        \n        constructor(nodes, graph, sources) {\n            this._graph = graph;\n            if (Array.isArray(nodes)) {\n                this.nodes = nodes;\n                /*if (this.nodes.length === 0) {\n                    throw \"Can't represent empty set of nodes\";\n                }*/\n            } else {\n                this.nodes = [nodes];\n            }\n            this.sources = sources;\n        }\n        \n        get graph() {\n            if (!this._graph) {\n                throw Error(\"Operation not possible as no Graph is available, try fetching first\");\n            }\n            return this._graph;\n        }\n        \n        get node() {\n            if (this.nodes.length !== 1) {\n                throw Error(\"Operation not possible as this GraphNode is underdetermined\");\n            }\n            return this.nodes[0];\n        }\n        \n        get termType() {\n            return this.node.termType;\n        }\n        \n        get value() {;\n            return this.node.value;\n        }\n        \n        fetch() {\n            if ((this.termType !== \"NamedNode\") || \n                        (this.sources && this.sources.indexOf(this.value.split(\"#\")[0]) > -1)) {\n                return Promise.resolve(this);\n            } else {\n                //TODO extend existing graph?\n                var uri = this.value.split(\"#\")[0];\n                return GraphNode.rdfFetch(uri).then(response => response.graph()).then(graph => GraphNode(this.node, graph, [uri]));\n            }\n        }\n        \n        /*\n         * \n         * @param {type} f\n         * @returns {unresolved} a promise that is satisfied when all promises returned by f are resolved\n         */\n        each(f) {\n            var results = this.nodes.map(node => f(GraphNode([node], this.graph, this.sources)));\n            return Promise.all(results);\n        }\n        \n        fetchEach(f) {\n            var results = this.nodes.map(node => GraphNode([node], this.graph, this.sources).fetch().then(f));\n            return Promise.all(results);\n        }\n\n        /**\n         * Returns a GraphNode for each node represented by this GraphNode\n         */\n        split() {\n            return this.nodes.map(node => GraphNode([node], this.graph, this.sources));\n        }\n        \n        out(predicate) {\n            var nodes = this.graph.each(this.node, predicate);\n            /*if (nodes.length === 0) {\n                throw \"No property \"+predicate+\" on \"+this.node;\n            }*/\n            return GraphNode(nodes, this.graph, this.sources);\n        }\n        \n        in(predicate) {\n            var statements = this.graph.statementsMatching(undefined, predicate, this.node);\n            /*if (statements.length === 0) {\n                throw \"No property \"+predicate+\" pointing to \"+this.node;\n            }*/\n            return GraphNode(statements.map(statement => statement.subject), this.graph, this.sources);\n        }\n    }\n\n/**\n * \n * Fetches an RDF graph. If the server return 401 the login process will be \n * started upon which the fetch will be retried.\n *\n * @param uri {string} The URI to be fetched\n * @param options passed to $rdf.Fetcher\n * @param login {boolean} The login function to be called, optional\n *\n * @return {Promise<Response>} Response has a `graph`property with the rertived graph\n */\nGraphNode.rdfFetch = function(uri, options, login) {\n    function plainFetch(uri, init = {}) {\n        if (!init.headers) {\n            init.headers = new Headers();\n        }\n        if (!init.headers.get(\"Accept\")) {\n            init.headers.set(\"Accept\", \"text/turtle;q=1, application/n-triples;q=.9, \"+\n                \"application/rdf+xml;q=.8, application/ld+json;q=.7, */*;q=.1\");\n        }\n        return fetch(uri, init).then(response => {\n            if (response.ok) {\n                response.graph = () => new Promise((resolve, reject) => {\n                    let graph = $rdf.graph();\n                    let mediaType = response.headers.get(\"Content-type\").split(\";\")[0];\n                    return response.text().then(text => {\n                        $rdf.parse(text, graph, uri, mediaType, (error, graph) => {\n                            if (error) {\n                                reject(error);\n                            } else {\n                                resolve(graph);\n                            }\n                        });\n                    });\n                });\n                return response;\n            } else {\n                return response;\n            }\n        });\n    };\n    var ggg = this;\n    return plainFetch(uri, options).then(function (response) {\n        if (response.status < 300) {\n            return response;\n        } else {\n            if (login && response.status === 401) {\n                console.log(\"Got 401 response, attempting to login\");\n                return login().then(function () {\n                    return ggg.rdfFetch(uri, options);\n                });\n            } else {\n                return response;\n            }\n        }\n    });\n};\n\nmodule.exports = GraphNode;\n"],"file":"GraphNode.js"}